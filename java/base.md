## 1.数据类型

### 装箱拆箱

- 装箱 Integer.valueOf(2)
，此方法会先判断值是否在缓存池中（-128~127）
- 拆箱 x.intValue()

### String

- Java8内部使用char数组存储数据；
- string是final修饰不可变，线程安全
- Stringbuffer用synchronized同步
- 每个字符串都是对象
String address=”上海^上海市@闵行区#吴中路”;
      String[] splitAddress=address.split(“\\^|@|#”);
生成字符串对象
1.通过构造方法
​ 每一次 new 都会在堆内存中开辟一个新的内存空间
所以即使内容相同，但是每个对象地址值不同
2.直接赋值方式
​ 以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，共享使用，并在堆内存中的字符串池中维护
“abbc”.split("b").length==3
stringbuilder.insert（index，object）

## 2.运算

- <<移位运算符，二进制下左移
- Float f=1.1；是错误的，1.1字面量是double类型；
- Short s=1；是错误的，1字面量是int类型
- +=隐含强制转换
- ^    逻辑异或    不同为true

## 3.控制语句

- for跳出多重循环，可以在前面加个标记A:,然后break A;即可

## 4.关键字

|private|默认| protected| public|
|--|--|--|--|
|该类| 同包| 同包加子类 ||

### final

- 修饰的变量只能修改属性
- 修饰的类不能被继承
- 修饰的方法能被继承，不能被子类重写
  - private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

### static

jvm加载一个class文件时，会对所有静态域进行初始化

> 初始化顺序

- 静态变量和静态块的初始化顺序取决于它们在代码中的顺序。
- 存在继承的情况下，初始化顺序为：
  - 父类（静态变量、静态语句块）
  - 子类（静态变量、静态语句块）
  - 父类（实例变量（属性）、普通语句块）
  - 父类（构造函数）
  - 子类（实例变量（属性）、普通语句块）
  - 子类（构造函数）

注：super必须写在子类构造方法的第一行

### this

本类对象的引用
修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题），也可以本类的成员方法，是本类对象的引用

### super

父类对象的引用
对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 ，完成父类的初始化，所以子类在构造的时候内存会更大

## 5.成员变量

- 又叫实例变量，也称为类的属性。
- 存在于堆内存中，有默认值。
- 加了static修饰后，所有对象共享

## 6.继承

> 继承是多态的前提

父类（基类、超类）；子类（派生类）
子类中所有的构造方法默认访问父类中的无参构造方法，如果父类没有无参构造方法就会报错，可以用super访问带参构造

## 7.多态

父类引用指向子类对象
向上转型（将指向转为父类，较小的内存，能使用的方法也只能是父类里面的）
 不能使用子类的特有成员

```test
假设有父类Fu ,其子类为Zi ,从对象的内存角度,假设Fu类里面的变量占内存2M, Zi 类里的变量占内存1M:
Fu f = new Fu ();//系统将分配2M内存
Zi z = new Zi ();//系统将分配3M内存(2+1)
因为子类中有一个隐藏的引用super会指向父类实例,所以在实例化子类之前会先实例化一个父类,也就是说会先执行父类的构造函数.所以z可以调用父类的方法.
Fu f1 = (Fu)z;//这时f1会指向那3M内存中的2M内存,即是说,f1只是指向了z中实例的父类实例对象,所以f1只能调用父类的方法(存储在2M内存中),而不能调用子类的方法(存储在1M内存中).
Zi z2= (Zi)f;//这句代码运行时会报ClassCastException.因为f中只有2M内存,而子类的引用都必须要有3M的内存,所以无法转换
Zi z3= (Zi)f1;//这句可以通过运行,这时z3指向那3M的内存.由于f1是由z转换过来的,所以它是有3M的内存的,只是它指向3M中的2M内存,类型转换时，就可以拿到全部3M。
```

好处
​ 提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作

## 8.抽象类&接口

## 5.内部类

> 访问规则

- 可以直接访问外部类的成员，包括私有
- 外部类要想访问内部类成员，必须创建对象

> new内部类

- 内部类不是静态的：外部类名.内部类名 对象名 = new 外部类名().new 内部类名();
- 内部类是静态的：外部类名.内部类名 对象名 = new 外部类名.内部类名();

> 局部内部类

- 方法内的内部类
- 局部内部类访问局部变量必须加final修饰。因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。所以，堆内存还是用该变量，而改变量已经没有了。为了让该值还存在，就加final修饰。
- 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用
该类可以直接访问外部类的成员，也可以访问方法内的局部变量

> 匿名内部类

是局部内部类的简化形式，其实是继承该类或者实现接口的子类匿名对象

## 5.object类方法

- Equals 对于引用类型，==判断其地址，equals没重写也是==
Hashcode
- Clone 是protected方法，不重写没法直接调用，根据规定还要实现Cloneable接口
 浅拷贝：前后是同一个对象super.clone
 深拷贝：对象不同
 clone拷贝会抛异常且进行类型转换，可以拷贝构造函数public A(A a){}

## 7.反射

## 8.异常

Throwable（Error 和 Exception）
 Error 用来表示 JVM 无法处理的错误
 Exception 分为两种：
  受检异常 ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；
  非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。
异常机制有一个原则：如果在catch中遇到了return或者异常等能使该函数终止的话那么有finally就必须先执行完finally代码块里面的代码然后再返回值。

## java3大特性

 封装: 隐藏内部功能的具体实现，只保留和外部交流数据的接口。提高代码的安全性和复用性。
 继承: 一个对象可以从它的父类继承所有的通用的属性和方法，并在无需重新编写原来的类的情况下对这些功能进行扩展；最大的好处是实现代码的高效重用。
 多态: 同一个动作作用于不同的对象 所产生不同的行为。例：人会吃饭，中国人用筷子，美国人用叉子。

## 序列化

什么情况下需要序列化？
1：当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；
2：当你想用套接字在网络上传送对象的时候；异常类都序列化了的
3：当你想通过RMI传输对象的时候；
​
   Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化

## 面向对象
